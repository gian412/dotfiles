module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/DataExtractionResult.ts":
/*!*************************************!*\
  !*** ./src/DataExtractionResult.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isVisualizationData(val) {
    if (typeof val !== "object" || !val || !("kind" in val)) {
        return false;
    }
    const obj = val;
    if (typeof obj.kind !== "object" || !obj.kind) {
        return false;
    }
    return Object.values(obj.kind).every(val => val === true);
}
exports.isVisualizationData = isVisualizationData;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./js */ "./src/js/index.ts"));
__export(__webpack_require__(/*! ./DataExtractionResult */ "./src/DataExtractionResult.ts"));


/***/ }),

/***/ "./src/js/api/DataExtractorApiImpl.ts":
/*!********************************************!*\
  !*** ./src/js/api/DataExtractorApiImpl.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const default_extractors_1 = __webpack_require__(/*! ./default-extractors */ "./src/js/api/default-extractors/index.ts");
/**
 * @internal
 */
class DataExtractorApiImpl {
    constructor() {
        this.extractors = new Map();
    }
    toJson(data) {
        return JSON.stringify(data);
    }
    registerExtractor(extractor) {
        this.extractors.set(extractor.id, extractor);
    }
    registerExtractors(extractors) {
        for (const e of extractors) {
            this.registerExtractor(e);
        }
    }
    getData(valueFn, evalFn, preferredDataExtractorId) {
        const extractions = new Array();
        const extractionCollector = {
            addExtraction(extraction) {
                extractions.push(extraction);
            },
        };
        DataExtractorApiImpl.lastEvalFn = evalFn;
        const value = valueFn();
        DataExtractorApiImpl.lastEvalFn = undefined;
        for (const e of this.extractors.values()) {
            e.getExtractions(value, extractionCollector, { evalFn });
        }
        extractions.sort((a, b) => b.priority - a.priority);
        let usedExtraction = extractions[0];
        if (!usedExtraction) {
            return this.toJson({ kind: "NoExtractors" });
        }
        if (preferredDataExtractorId) {
            const preferred = extractions.find(e => e.id === preferredDataExtractorId);
            if (preferred) {
                usedExtraction = preferred;
            }
        }
        function mapExtractor(e) {
            return {
                id: e.id,
                name: e.name,
                priority: e.priority,
            };
        }
        const data = usedExtraction.extractData();
        return this.toJson({
            kind: "Data",
            extractionResult: {
                data,
                usedExtractor: mapExtractor(usedExtraction),
                availableExtractors: extractions.map(mapExtractor),
            },
        });
    }
    registerDefaultExtractors(preferExisting = false) {
        // TODO consider preferExisting
        default_extractors_1.registerDefaultExtractors(this);
    }
}
exports.DataExtractorApiImpl = DataExtractorApiImpl;


/***/ }),

/***/ "./src/js/api/default-extractors/AsIsDataExtractor.ts":
/*!************************************************************!*\
  !*** ./src/js/api/default-extractors/AsIsDataExtractor.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DataExtractionResult_1 = __webpack_require__(/*! ../../../DataExtractionResult */ "./src/DataExtractionResult.ts");
class AsIsDataExtractor {
    constructor() {
        this.id = "as-is";
    }
    getExtractions(data, extractionCollector, context) {
        if (!DataExtractionResult_1.isVisualizationData(data)) {
            return;
        }
        extractionCollector.addExtraction({
            id: this.id,
            name: "As Is",
            priority: 500,
            extractData() {
                return data;
            },
        });
    }
}
exports.AsIsDataExtractor = AsIsDataExtractor;


/***/ }),

/***/ "./src/js/api/default-extractors/GetDebugVisualizationDataExtractor.ts":
/*!*****************************************************************************!*\
  !*** ./src/js/api/default-extractors/GetDebugVisualizationDataExtractor.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GetVisualizationDataExtractor {
    constructor() {
        this.id = "get-visualization-data";
    }
    getExtractions(data, collector, context) {
        if (typeof data !== "object" || !data) {
            return;
        }
        const getVisualizationData = data
            .getVisualizationData;
        if (typeof getVisualizationData !== "function") {
            return;
        }
        collector.addExtraction({
            id: this.id,
            name: "Use Method 'getVisualizationData'",
            priority: 600,
            extractData() {
                return getVisualizationData.apply(data);
            },
        });
    }
}
exports.GetVisualizationDataExtractor = GetVisualizationDataExtractor;


/***/ }),

/***/ "./src/js/api/default-extractors/GridExtractor.ts":
/*!********************************************************!*\
  !*** ./src/js/api/default-extractors/GridExtractor.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../../util */ "./src/util.ts");
class GridExtractor {
    constructor() {
        this.id = "grid";
    }
    getExtractions(data, extractionCollector, context) {
        if (!Array.isArray(data)) {
            return;
        }
        extractionCollector.addExtraction({
            id: this.id,
            name: "Array As Grid",
            priority: 500,
            extractData: () => util_1.expect({
                kind: { grid: true },
                rows: [{ columns: data.map(d => ({ tag: "" + d })) }],
            }),
        });
    }
}
exports.GridExtractor = GridExtractor;


/***/ }),

/***/ "./src/js/api/default-extractors/ObjectGraphExtractor.ts":
/*!***************************************************************!*\
  !*** ./src/js/api/default-extractors/ObjectGraphExtractor.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = __webpack_require__(/*! ../../helpers */ "./src/js/helpers/index.ts");
class ObjectGraphExtractor {
    constructor() {
        this.id = "object-graph";
    }
    getExtractions(data, collector, context) {
        function isObject(val) {
            if (typeof val !== "object") {
                return false;
            }
            if (!val) {
                return false;
            }
            return true;
        }
        if (!isObject(data)) {
            return;
        }
        collector.addExtraction({
            id: "object-graph",
            name: "Object Graph",
            priority: 99,
            extractData() {
                return helpers_1.createGraph([data], item => {
                    let label = "";
                    const edges = new Array();
                    if (item instanceof Set) {
                        label = "Set";
                        for (const value of item.values()) {
                            if (isObject(value)) {
                                edges.push({ label: "item", to: value });
                            }
                        }
                    }
                    else if (item instanceof Map) {
                        label = "Map";
                        for (const [key, value] of item.entries()) {
                            if (isObject(value)) {
                                edges.push({ label: key, to: value });
                            }
                        }
                    }
                    else {
                        for (const [key, val] of Object.entries(item)) {
                            if (isObject(val)) {
                                edges.push({ label: key, to: val });
                            }
                        }
                        const className = item.constructor
                            ? item.constructor.name
                            : "?";
                        label = className;
                    }
                    return {
                        shape: "box",
                        edges,
                        color: item === data ? "lightblue" : undefined,
                        label,
                    };
                }, { maxSize: 50 });
            },
        });
    }
}
exports.ObjectGraphExtractor = ObjectGraphExtractor;


/***/ }),

/***/ "./src/js/api/default-extractors/PlotlyDataExtractor.ts":
/*!**************************************************************!*\
  !*** ./src/js/api/default-extractors/PlotlyDataExtractor.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../../util */ "./src/util.ts");
class PlotlyDataExtractor {
    constructor() {
        this.id = "plot";
    }
    getExtractions(data, collector, context) {
        if (!Array.isArray(data)) {
            return;
        }
        if (data.some(x => typeof x !== "number")) {
            return;
        }
        collector.addExtraction({
            id: "plot-y",
            name: "Plot as y-Values",
            priority: 1001,
            extractData: () => util_1.expect({
                kind: {
                    plotly: true,
                },
                data: [{ y: data }],
            }),
        });
    }
}
exports.PlotlyDataExtractor = PlotlyDataExtractor;


/***/ }),

/***/ "./src/js/api/default-extractors/TableExtractor.ts":
/*!*********************************************************!*\
  !*** ./src/js/api/default-extractors/TableExtractor.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../../util */ "./src/util.ts");
function assert(value) { }
class TableDataExtractor {
    constructor() {
        this.id = "table";
    }
    getExtractions(data, collector, context) {
        if (!Array.isArray(data)) {
            return;
        }
        if (!data.every(d => typeof d === "object" && d)) {
            return;
        }
        assert(data);
        collector.addExtraction({
            id: "table",
            name: "Table",
            priority: 1000,
            extractData() {
                return util_1.expect({
                    kind: {
                        table: true,
                    },
                    rows: data,
                });
            },
        });
    }
}
exports.TableDataExtractor = TableDataExtractor;


/***/ }),

/***/ "./src/js/api/default-extractors/ToStringExtractor.ts":
/*!************************************************************!*\
  !*** ./src/js/api/default-extractors/ToStringExtractor.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../../util */ "./src/util.ts");
class ToStringDataExtractor {
    constructor() {
        this.id = "to-string";
    }
    getExtractions(data, collector, context) {
        collector.addExtraction({
            id: "to-string",
            name: "To String",
            priority: 100,
            extractData() {
                return util_1.expect({
                    kind: {
                        text: true,
                    },
                    text: "" + data,
                });
            },
        });
    }
}
exports.ToStringDataExtractor = ToStringDataExtractor;


/***/ }),

/***/ "./src/js/api/default-extractors/TypeScriptDataExtractors.ts":
/*!*******************************************************************!*\
  !*** ./src/js/api/default-extractors/TypeScriptDataExtractors.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../../util */ "./src/util.ts");
class TypeScriptAstDataExtractor {
    constructor() {
        this.id = "typescript-ast";
    }
    getExtractions(data, collector, { evalFn }) {
        if (!data) {
            return;
        }
        function getApi() {
            if (typeof data === "object" && "typescript" in data) {
                return data.typescript;
            }
            else {
                // This might refer to global.require which uses CWD for resolution!
                const require = evalFn("require");
                return require("typescript");
            }
        }
        let tsApi;
        try {
            tsApi = getApi();
            if (!tsApi) {
                return;
            }
        }
        catch (e) {
            return;
        }
        const helper = new Helper(tsApi);
        let rootSourceFile = undefined;
        let rootNode = undefined;
        let marked;
        let fn = (n) => undefined;
        if (Array.isArray(data) &&
            data.every(helper.isNode) &&
            data.length > 0) {
            rootSourceFile = helper.getSourceFile(data[0]);
            marked = new Set(data);
        }
        else if (helper.isNode(data)) {
            rootSourceFile = helper.getSourceFile(data);
            marked = new Set([data]);
        }
        else if (typeof data === "object" && data) {
            marked = new Set();
            const map = new Map();
            fn = (n) => map.get(n);
            for (const [key, item] of Object.entries(data)) {
                if (key === "fn") {
                    fn = item;
                }
                else if (key === "typescript") {
                }
                else {
                    if (key === "rootNode") {
                        rootNode = item;
                    }
                    let nodes;
                    if (helper.isNode(item)) {
                        nodes = [item];
                    }
                    else if (Array.isArray(item) &&
                        item.every(helper.isNode)) {
                        nodes = item;
                    }
                    else {
                        return;
                    }
                    if (nodes.length > 0 && !rootSourceFile) {
                        rootSourceFile = helper.getSourceFile(nodes[0]);
                    }
                    for (const n of nodes) {
                        marked.add(n);
                        map.set(n, key);
                    }
                }
            }
        }
        else {
            return;
        }
        if (!rootSourceFile) {
            return;
        }
        const finalRootSourceFile = rootSourceFile;
        collector.addExtraction({
            id: "ts-ast",
            name: "TypeScript AST",
            priority: 1000,
            extractData() {
                return util_1.expect({
                    kind: { text: true, tree: true, ast: true },
                    root: helper.toTreeNode(rootNode || finalRootSourceFile, "root", "", marked, fn),
                    text: finalRootSourceFile.text,
                    fileName: "index.ts",
                });
            },
        });
    }
}
exports.TypeScriptAstDataExtractor = TypeScriptAstDataExtractor;
class Helper {
    constructor(tsApi) {
        this.tsApi = tsApi;
        this.isNode = (node) => {
            return (typeof node === "object" &&
                node !== null &&
                (this.tsApi.isToken(node) ||
                    this.tsApi.isNode(node)));
        };
    }
    getPropertyNameInParent(value, parent) {
        for (const propertyName in parent) {
            if (propertyName.startsWith("_"))
                continue;
            const member = parent[propertyName];
            if (member === value) {
                return propertyName;
            }
            if (Array.isArray(member)) {
                const index = member.indexOf(value);
                if (index !== -1) {
                    return `${propertyName}[${index}]`;
                }
            }
        }
        return undefined;
    }
    getChildren(node) {
        const result = new Array();
        this.tsApi.forEachChild(node, n => {
            result.push(n);
        });
        return result;
    }
    toTreeNode(node, memberName, segmentName, marked, emphasizedValueFn) {
        const name = this.tsApi.SyntaxKind[node.kind];
        const children = this.getChildren(node)
            .map((childNode, idx) => {
            let parentPropertyName = this.getPropertyNameInParent(childNode, node) || "";
            if (childNode.kind == this.tsApi.SyntaxKind.SyntaxList) {
                const children = this.getChildren(childNode);
                for (const c of children) {
                    const name = this.getPropertyNameInParent(c, node) || "";
                    if (name) {
                        parentPropertyName = name;
                        break;
                    }
                }
            }
            let segmentName = "." + parentPropertyName;
            if (node.kind == this.tsApi.SyntaxKind.SyntaxList) {
                parentPropertyName = "" + idx;
                segmentName = `[${idx}]`;
            }
            return this.toTreeNode(childNode, parentPropertyName, segmentName, marked, emphasizedValueFn);
        })
            .filter(c => c !== null);
        let value = undefined;
        if (this.tsApi.isIdentifier(node)) {
            value = node.text || node.escapedText;
        }
        else if (this.tsApi.isLiteralExpression(node)) {
            value = node.text;
        }
        const items = [
            { text: `${memberName}: `, emphasis: "style1" },
            { text: name },
        ];
        const emphasizedVal = emphasizedValueFn(node);
        if (value) {
            items.push({ text: value, emphasis: "style2" });
        }
        if (emphasizedVal) {
            items.push({ text: emphasizedVal, emphasis: "style3" });
        }
        return {
            items,
            children: children,
            segment: segmentName,
            span: {
                length: node.end - node.pos,
                start: node.pos,
            },
            isMarked: marked.has(node),
        };
    }
    getSourceFile(node) {
        if (!node) {
            throw new Error("Detached node");
        }
        if (this.tsApi.isSourceFile(node)) {
            return node;
        }
        if (!("getSourceFile" in node)) {
            return this.getSourceFile(node.parent);
        }
        return node.getSourceFile();
    }
}


/***/ }),

/***/ "./src/js/api/default-extractors/index.ts":
/*!************************************************!*\
  !*** ./src/js/api/default-extractors/index.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var registerDefaultDataExtractors_1 = __webpack_require__(/*! ./registerDefaultDataExtractors */ "./src/js/api/default-extractors/registerDefaultDataExtractors.ts");
exports.registerDefaultExtractors = registerDefaultDataExtractors_1.registerDefaultExtractors;


/***/ }),

/***/ "./src/js/api/default-extractors/registerDefaultDataExtractors.ts":
/*!************************************************************************!*\
  !*** ./src/js/api/default-extractors/registerDefaultDataExtractors.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TypeScriptDataExtractors_1 = __webpack_require__(/*! ./TypeScriptDataExtractors */ "./src/js/api/default-extractors/TypeScriptDataExtractors.ts");
const AsIsDataExtractor_1 = __webpack_require__(/*! ./AsIsDataExtractor */ "./src/js/api/default-extractors/AsIsDataExtractor.ts");
const GetDebugVisualizationDataExtractor_1 = __webpack_require__(/*! ./GetDebugVisualizationDataExtractor */ "./src/js/api/default-extractors/GetDebugVisualizationDataExtractor.ts");
const ToStringExtractor_1 = __webpack_require__(/*! ./ToStringExtractor */ "./src/js/api/default-extractors/ToStringExtractor.ts");
const PlotlyDataExtractor_1 = __webpack_require__(/*! ./PlotlyDataExtractor */ "./src/js/api/default-extractors/PlotlyDataExtractor.ts");
const ObjectGraphExtractor_1 = __webpack_require__(/*! ./ObjectGraphExtractor */ "./src/js/api/default-extractors/ObjectGraphExtractor.ts");
const injection_1 = __webpack_require__(/*! ../injection */ "./src/js/api/injection.ts");
const GridExtractor_1 = __webpack_require__(/*! ./GridExtractor */ "./src/js/api/default-extractors/GridExtractor.ts");
const TableExtractor_1 = __webpack_require__(/*! ./TableExtractor */ "./src/js/api/default-extractors/TableExtractor.ts");
/**
 * The default data extractors should be registered by VS Code automatically.
 * Registering them manually ensures that they are up to date.
 */
function registerDefaultExtractors(api = injection_1.getDataExtractorApi()) {
    for (const item of [
        new TypeScriptDataExtractors_1.TypeScriptAstDataExtractor(),
        new AsIsDataExtractor_1.AsIsDataExtractor(),
        new GetDebugVisualizationDataExtractor_1.GetVisualizationDataExtractor(),
        new ToStringExtractor_1.ToStringDataExtractor(),
        new PlotlyDataExtractor_1.PlotlyDataExtractor(),
        new ObjectGraphExtractor_1.ObjectGraphExtractor(),
        new GridExtractor_1.GridExtractor(),
        new TableExtractor_1.TableDataExtractor(),
    ]) {
        api.registerExtractor(item);
    }
}
exports.registerDefaultExtractors = registerDefaultExtractors;


/***/ }),

/***/ "./src/js/api/index.ts":
/*!*****************************!*\
  !*** ./src/js/api/index.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./injection */ "./src/js/api/injection.ts"));
var DataExtractorApiImpl_1 = __webpack_require__(/*! ./DataExtractorApiImpl */ "./src/js/api/DataExtractorApiImpl.ts");
exports.DataExtractorApiImpl = DataExtractorApiImpl_1.DataExtractorApiImpl;


/***/ }),

/***/ "./src/js/api/injection.ts":
/*!*********************************!*\
  !*** ./src/js/api/injection.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DataExtractorApiImpl_1 = __webpack_require__(/*! ./DataExtractorApiImpl */ "./src/js/api/DataExtractorApiImpl.ts");
const helpers = __webpack_require__(/*! ../helpers */ "./src/js/helpers/index.ts");
const globalHelpers = __webpack_require__(/*! ../global-helpers */ "./src/js/global-helpers.ts");
/**
 * Returns standalone JS code representing an expression that initializes the data extraction API.
 * This expression returns nothing.
 * This function is called in the VS Code extension, the expression is evaluated in the debugee.
 */
function getExpressionToInitializeDataExtractorApi() {
    const _fs = __webpack_require__(/*! fs */ "fs");
    const moduleSrc = _fs.readFileSync(__filename, { encoding: "utf8" });
    return `((function () {
		let module = {};
		${moduleSrc}
		return module.exports.getDataExtractorApi();
	})())`;
}
exports.getExpressionToInitializeDataExtractorApi = getExpressionToInitializeDataExtractorApi;
/**
 * Returns standalone JS code representing an expression returns the data extraction API.
 * This expression returns an object of type `DataExtractorApi`.
 * If the API must be initialized with `getExpressionToInitializeDataExtractorApi()`,
 * it throws an exception containing the text of `ApiHasNotBeenInitializedCode`.
 * This function is called in the VS Code extension, the expression is evaluated in the debugee.
 */
function getExpressionForDataExtractorApi() {
    return `((${selfContainedGetInitializedDataExtractorApi.toString()})())`;
}
exports.getExpressionForDataExtractorApi = getExpressionForDataExtractorApi;
const apiKey = "@hediet/data-extractor-api/v2";
function getDataExtractorApi() {
    installHelpers();
    const globalObj = typeof window === "object" ? window : global;
    if (!globalObj[apiKey]) {
        globalObj[apiKey] = new DataExtractorApiImpl_1.DataExtractorApiImpl();
    }
    return globalObj[apiKey];
}
exports.getDataExtractorApi = getDataExtractorApi;
/**
 * This code is used to detect if the API has not been initialized yet.
 * @internal
 */
exports.ApiHasNotBeenInitializedCode = "EgH0cybXij1jYUozyakO";
/**
 * @internal
 */
function selfContainedGetInitializedDataExtractorApi() {
    const globalObj = typeof window === "object" ? window : global;
    const key = "@hediet/data-extractor-api/v2";
    let api = globalObj[key];
    if (!api) {
        const code = "EgH0cybXij1jYUozyakO";
        throw new Error(`Data Extractor API has not been initialized. Code: ${code}`);
    }
    return api;
}
function installHelpers() {
    const globalObj = typeof window === "object" ? window : global;
    // `hediet` as prefix to avoid name collision (I own `hediet.de`).
    globalObj["hedietDbgVis"] = { ...helpers, ...globalHelpers };
}
exports.installHelpers = installHelpers;


/***/ }),

/***/ "./src/js/global-helpers.ts":
/*!**********************************!*\
  !*** ./src/js/global-helpers.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var injection_1 = __webpack_require__(/*! ./api/injection */ "./src/js/api/injection.ts");
exports.getApi = injection_1.getDataExtractorApi;


/***/ }),

/***/ "./src/js/helpers/asData.ts":
/*!**********************************!*\
  !*** ./src/js/helpers/asData.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function asData(data) {
    return data;
}
exports.asData = asData;


/***/ }),

/***/ "./src/js/helpers/cache.ts":
/*!*********************************!*\
  !*** ./src/js/helpers/cache.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = __webpack_require__(/*! ../api */ "./src/js/api/index.ts");
const cached = new Map();
/**
 * Evaluates an expression
 */
function cache(expression, id = undefined) {
    let resultFn;
    let key;
    if (typeof expression === "string") {
        const evalFn = api_1.DataExtractorApiImpl.lastEvalFn;
        resultFn = () => evalFn(expression);
        key = JSON.stringify({ expr: expression, id });
    }
    else {
        resultFn = () => expression();
        key = JSON.stringify({ expr: expression.toString(), id });
    }
    if (cached.has(key)) {
        return cached.get(key);
    }
    const result = resultFn();
    cached.set(key, result);
    return result;
}
exports.cache = cache;


/***/ }),

/***/ "./src/js/helpers/createGraph.ts":
/*!***************************************!*\
  !*** ./src/js/helpers/createGraph.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Given a list of roots, it creates a graph by following their edges recursively.
 * Tracks cycles.
 */
function createGraph(roots, infoSelector, options = {}) {
    const r = {
        kind: {
            graph: true,
        },
        nodes: [],
        edges: [],
    };
    let idCounter = 1;
    const ids = new Map();
    function getId(item) {
        const _id = infoSelector(item).id;
        if (_id !== undefined) {
            return "" + _id;
        }
        let id = ids.get(item);
        if (!id) {
            id = `hediet.de/id-${idCounter++}`;
            ids.set(item, id);
        }
        return id;
    }
    const queue = new Array(...roots.map(r => ({ item: r, dist: 0 })));
    const processed = new Set();
    while (queue.length > 0) {
        const { item, dist } = queue.shift();
        if (processed.has(item)) {
            continue;
        }
        processed.add(item);
        const nodeInfo = infoSelector(item);
        const fromId = getId(item);
        r.nodes.push({ ...nodeInfo, id: fromId, ["edges"]: undefined });
        for (const e of nodeInfo.edges) {
            const toId = getId(e.to);
            r.edges.push({
                ...e,
                from: fromId,
                to: toId,
            });
            let shouldPush = !processed.has(e.to);
            if (options.maxSize &&
                processed.size + queue.length > options.maxSize) {
                shouldPush = false;
            }
            if (shouldPush) {
                queue.push({ item: e.to, dist: dist + 1 });
            }
        }
    }
    return r;
}
exports.createGraph = createGraph;


/***/ }),

/***/ "./src/js/helpers/createGraphFromPointers.ts":
/*!***************************************************!*\
  !*** ./src/js/helpers/createGraphFromPointers.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const createGraph_1 = __webpack_require__(/*! ./createGraph */ "./src/js/helpers/createGraph.ts");
/**
 * Given a labeled list of roots, it creates a graph by following their edges recursively.
 * Tracks cycles.
 */
function createGraphFromPointers(roots, infoSelector) {
    const marker = {};
    const items = Object.entries(roots).map(([name, value]) => ({
        marker,
        name,
        value,
    }));
    return createGraph_1.createGraph(items, item => {
        if ("marker" in item && item["marker"] === marker) {
            return {
                id: "label____" + item.name,
                color: "orange",
                label: item.name,
                edges: [{ to: item.value, color: "orange", label: "" }].filter(t => !!t.to),
            };
        }
        else {
            return infoSelector(item);
        }
    });
}
exports.createGraphFromPointers = createGraphFromPointers;


/***/ }),

/***/ "./src/js/helpers/index.ts":
/*!*********************************!*\
  !*** ./src/js/helpers/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./createGraph */ "./src/js/helpers/createGraph.ts"));
__export(__webpack_require__(/*! ./createGraphFromPointers */ "./src/js/helpers/createGraphFromPointers.ts"));
__export(__webpack_require__(/*! ./tryEval */ "./src/js/helpers/tryEval.ts"));
__export(__webpack_require__(/*! ./markedGrid */ "./src/js/helpers/markedGrid.ts"));
__export(__webpack_require__(/*! ./cache */ "./src/js/helpers/cache.ts"));
__export(__webpack_require__(/*! ./asData */ "./src/js/helpers/asData.ts"));


/***/ }),

/***/ "./src/js/helpers/markedGrid.ts":
/*!**************************************!*\
  !*** ./src/js/helpers/markedGrid.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function markedGrid(arr, marked) {
    return {
        kind: { grid: true },
        rows: [{ columns: arr.map(d => ({ tag: d })) }],
        markers: Object.entries(marked).map(([key, val]) => ({
            id: key,
            row: 0,
            column: val,
        })),
    };
}
exports.markedGrid = markedGrid;


/***/ }),

/***/ "./src/js/helpers/tryEval.ts":
/*!***********************************!*\
  !*** ./src/js/helpers/tryEval.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DataExtractorApiImpl_1 = __webpack_require__(/*! ../api/DataExtractorApiImpl */ "./src/js/api/DataExtractorApiImpl.ts");
function tryEval(obj) {
    const result = {};
    const evalFn = DataExtractorApiImpl_1.DataExtractorApiImpl.lastEvalFn;
    if (Array.isArray(obj)) {
        for (const val of obj) {
            try {
                result[val] = evalFn(val);
            }
            catch (e) { }
        }
    }
    else {
        for (const [key, val] of Object.entries(obj)) {
            try {
                result[key] = evalFn(val);
            }
            catch (e) { }
        }
    }
    return result;
}
exports.tryEval = tryEval;


/***/ }),

/***/ "./src/js/index.ts":
/*!*************************!*\
  !*** ./src/js/index.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./api */ "./src/js/api/index.ts"));
__export(__webpack_require__(/*! ./helpers */ "./src/js/helpers/index.ts"));
var default_extractors_1 = __webpack_require__(/*! ./api/default-extractors */ "./src/js/api/default-extractors/index.ts");
exports.registerDefaultExtractors = default_extractors_1.registerDefaultExtractors;


/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function expect(data) {
    return data;
}
exports.expect = expect;


/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ })

/******/ });
//# sourceMappingURL=index.js.map